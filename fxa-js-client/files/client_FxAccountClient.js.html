<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>client/FxAccountClient.js - fxa-js-client</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="fxa-js-client" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.0.20</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/credentials.html">credentials</a></li>
                                <li><a href="../classes/FxAccountClient.html">FxAccountClient</a></li>
                                <li><a href="../classes/hawkCredentials.html">hawkCredentials</a></li>
                                <li><a href="../classes/hkdf.html">hkdf</a></li>
                                <li><a href="../classes/pbkdf2.html">pbkdf2</a></li>
                                <li><a href="../classes/Request.html">Request</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: client/FxAccountClient.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

&#x27;use strict&#x27;;

const ES6Promise = require(&#x27;es6-promise&#x27;);
const sjcl = require(&#x27;sjcl&#x27;);
const credentials = require(&#x27;./lib/credentials&#x27;);
const ERRORS = require(&#x27;./lib/errors&#x27;);
const hawkCredentials = require(&#x27;./lib/hawkCredentials&#x27;);
const metricsContext = require(&#x27;./lib/metricsContext&#x27;);
const Request = require(&#x27;./lib/request&#x27;);

// polyfill ES6 promises on browsers that do not support them.
ES6Promise.polyfill();

var VERSION = &#x27;v1&#x27;;
var uriVersionRegExp = new RegExp(&#x27;/&#x27; + VERSION + &#x27;$&#x27;);
var HKDF_SIZE = 2 * 32;

function isUndefined(val) {
  return typeof val === &#x27;undefined&#x27;;
}

function isNull(val) {
  return val === null;
}

function isEmptyObject(val) {
  return (
    Object.prototype.toString.call(val) === &#x27;[object Object]&#x27; &amp;&amp;
    !Object.keys(val).length
  );
}

function isEmptyString(val) {
  return val === &#x27;&#x27;;
}

function required(val, name) {
  if (
    isUndefined(val) ||
    isNull(val) ||
    isEmptyObject(val) ||
    isEmptyString(val)
  ) {
    throw new Error(&#x27;Missing &#x27; + name);
  }
}

/**
 * @class FxAccountClient
 * @constructor
 * @param {String} uri Auth Server URI
 * @param {Object} config Configuration
 */
function FxAccountClient(uri, config) {
  if (!uri &amp;&amp; !config) {
    throw new Error(
      &#x27;Firefox Accounts auth server endpoint or configuration object required.&#x27;
    );
  }

  if (typeof uri !== &#x27;string&#x27;) {
    config = uri || {};
    uri = config.uri;
  }

  if (typeof config === &#x27;undefined&#x27;) {
    config = {};
  }

  if (!uri) {
    throw new Error(&#x27;FxA auth server uri not set.&#x27;);
  }

  if (!uriVersionRegExp.test(uri)) {
    uri = uri + &#x27;/&#x27; + VERSION;
  }

  this.request = new Request(uri, config.xhr, {
    localtimeOffsetMsec: config.localtimeOffsetMsec,
  });
}

FxAccountClient.VERSION = VERSION;

/**
 * @method signUp
 * @param {String} email Email input
 * @param {String} password Password input
 * @param {Object} [options={}] Options
 *   @param {Boolean} [options.keys]
 *   If &#x60;true&#x60;, calls the API with &#x60;?keys=true&#x60; to get the keyFetchToken
 *   @param {String} [options.service]
 *   Opaque alphanumeric token to be included in verification links
 *   @param {String} [options.redirectTo]
 *   a URL that the client should be redirected to after handling the request
 *   @param {String} [options.preVerified]
 *   set email to be verified if possible
 *   @param {String} [options.resume]
 *   Opaque url-encoded string that will be included in the verification link
 *   as a querystring parameter, useful for continuing an OAuth flow for
 *   example.
 *   @param {String} [options.lang]
 *   set the language for the &#x27;Accept-Language&#x27; header
 *   @param {String} [options.style]
 *   Specify the style of confirmation emails
 *   @param {String} [options.verificationMethod]
 *   Specify the verification method to confirm the account with
 *   @param {Object} [options.metricsContext={}] Metrics context metadata
 *     @param {String} options.metricsContext.deviceId identifier for the current device
 *     @param {String} options.metricsContext.flowId identifier for the current event flow
 *     @param {Number} options.metricsContext.flowBeginTime flow.begin event time
 *     @param {Number} options.metricsContext.utmCampaign marketing campaign identifier
 *     @param {Number} options.metricsContext.utmContent content identifier
 *     @param {Number} options.metricsContext.utmMedium acquisition medium
 *     @param {Number} options.metricsContext.utmSource traffic source
 *     @param {Number} options.metricsContext.utmTerm search terms
 * @return {Promise} A promise that will be fulfilled with JSON &#x60;xhr.responseText&#x60; of the request
 */
FxAccountClient.prototype.signUp = function(email, password, options) {
  var self = this;

  return Promise.resolve()
    .then(function() {
      required(email, &#x27;email&#x27;);
      required(password, &#x27;password&#x27;);

      return credentials.setup(email, password);
    })
    .then(function(result) {
      /*eslint complexity: [2, 13] */
      var endpoint = &#x27;/account/create&#x27;;
      var data = {
        email: result.emailUTF8,
        authPW: sjcl.codec.hex.fromBits(result.authPW),
      };
      var requestOpts = {};

      if (options) {
        if (options.service) {
          data.service = options.service;
        }

        if (options.redirectTo) {
          data.redirectTo = options.redirectTo;
        }

        // preVerified is used for unit/functional testing
        if (options.preVerified) {
          data.preVerified = options.preVerified;
        }

        if (options.resume) {
          data.resume = options.resume;
        }

        if (options.keys) {
          endpoint += &#x27;?keys=true&#x27;;
        }

        if (options.lang) {
          requestOpts.headers = {
            &#x27;Accept-Language&#x27;: options.lang,
          };
        }

        if (options.metricsContext) {
          data.metricsContext = metricsContext.marshall(options.metricsContext);
        }

        if (options.style) {
          data.style = options.style;
        }

        if (options.verificationMethod) {
          data.verificationMethod = options.verificationMethod;
        }
      }

      return self.request
        .send(endpoint, &#x27;POST&#x27;, null, data, requestOpts)
        .then(function(accountData) {
          if (options &amp;&amp; options.keys) {
            accountData.unwrapBKey = sjcl.codec.hex.fromBits(result.unwrapBKey);
          }
          return accountData;
        });
    });
};

/**
 * @method signIn
 * @param {String} email Email input
 * @param {String} password Password input
 * @param {Object} [options={}] Options
 *   @param {Boolean} [options.keys]
 *   If &#x60;true&#x60;, calls the API with &#x60;?keys=true&#x60; to get the keyFetchToken
 *   @param {Boolean} [options.skipCaseError]
 *   If &#x60;true&#x60;, the request will skip the incorrect case error
 *   @param {String} [options.service]
 *   Service being signed into
 *   @param {String} [options.reason]
 *   Reason for sign in. Can be one of: &#x60;signin&#x60;, &#x60;password_check&#x60;,
 *   &#x60;password_change&#x60;, &#x60;password_reset&#x60;
 *   @param {String} [options.redirectTo]
 *   a URL that the client should be redirected to after handling the request
 *   @param {String} [options.resume]
 *   Opaque url-encoded string that will be included in the verification link
 *   as a querystring parameter, useful for continuing an OAuth flow for
 *   example.
 *   @param {String} [options.originalLoginEmail]
 *   If retrying after an &quot;incorrect email case&quot; error, this specifies
 *   the email address as originally entered by the user.
 *   @param {String} [options.verificationMethod]
 *   Request a specific verification method be used for verifying the session,
 *   e.g. &#x27;email-2fa&#x27; or &#x27;totp-2fa&#x27;.
 *   @param {Object} [options.metricsContext={}] Metrics context metadata
 *     @param {String} options.metricsContext.deviceId identifier for the current device
 *     @param {String} options.metricsContext.flowId identifier for the current event flow
 *     @param {Number} options.metricsContext.flowBeginTime flow.begin event time
 *     @param {Number} options.metricsContext.utmCampaign marketing campaign identifier
 *     @param {Number} options.metricsContext.utmContent content identifier
 *     @param {Number} options.metricsContext.utmMedium acquisition medium
 *     @param {Number} options.metricsContext.utmSource traffic source
 *     @param {Number} options.metricsContext.utmTerm search terms
 *   @param {String} [options.unblockCode]
 *   Login unblock code.
 * @return {Promise} A promise that will be fulfilled with JSON &#x60;xhr.responseText&#x60; of the request
 */
FxAccountClient.prototype.signIn = function(email, password, options) {
  var self = this;
  options = options || {};

  return Promise.resolve()
    .then(function() {
      required(email, &#x27;email&#x27;);
      required(password, &#x27;password&#x27;);

      return credentials.setup(email, password);
    })
    .then(function(result) {
      var endpoint = &#x27;/account/login&#x27;;

      if (options.keys) {
        endpoint += &#x27;?keys=true&#x27;;
      }

      var data = {
        email: result.emailUTF8,
        authPW: sjcl.codec.hex.fromBits(result.authPW),
      };

      if (options.metricsContext) {
        data.metricsContext = metricsContext.marshall(options.metricsContext);
      }

      if (options.reason) {
        data.reason = options.reason;
      }

      if (options.redirectTo) {
        data.redirectTo = options.redirectTo;
      }

      if (options.resume) {
        data.resume = options.resume;
      }

      if (options.service) {
        data.service = options.service;
      }

      if (options.unblockCode) {
        data.unblockCode = options.unblockCode;
      }

      if (options.originalLoginEmail) {
        data.originalLoginEmail = options.originalLoginEmail;
      }

      if (options.verificationMethod) {
        data.verificationMethod = options.verificationMethod;
      }

      return self.request.send(endpoint, &#x27;POST&#x27;, null, data).then(
        function(accountData) {
          if (options.keys) {
            accountData.unwrapBKey = sjcl.codec.hex.fromBits(result.unwrapBKey);
          }
          return accountData;
        },
        function(error) {
          if (
            error &amp;&amp;
            error.email &amp;&amp;
            error.errno === ERRORS.INCORRECT_EMAIL_CASE &amp;&amp;
            !options.skipCaseError
          ) {
            options.skipCaseError = true;
            options.originalLoginEmail = email;

            return self.signIn(error.email, password, options);
          } else {
            throw error;
          }
        }
      );
    });
};

/**
 * @method verifyCode
 * @param {String} uid Account ID
 * @param {String} code Verification code
 * @param {Object} [options={}] Options
 *   @param {String} [options.service]
 *   Service being signed into
 *   @param {String} [options.reminder]
 *   Reminder that was used to verify the account
 *   @param {String} [options.type]
 *   Type of code being verified, only supports &#x60;secondary&#x60; otherwise will verify account/sign-in
 *   @param {Boolean} [options.marketingOptIn]
 *   If &#x60;true&#x60;, notifies marketing of opt-in intent.
 *   @param {Array} [options.newsletters]
 *   Array of newsletters to opt into.
 *   @param {String} [options.style]
 *   Specify the style of email to send.
 * @return {Promise} A promise that will be fulfilled with JSON &#x60;xhr.responseText&#x60; of the request
 */
FxAccountClient.prototype.verifyCode = function(uid, code, options) {
  var self = this;

  return Promise.resolve().then(function() {
    required(uid, &#x27;uid&#x27;);
    required(code, &#x27;verify code&#x27;);

    var data = {
      uid: uid,
      code: code,
    };

    if (options) {
      if (options.service) {
        data.service = options.service;
      }

      if (options.reminder) {
        data.reminder = options.reminder;
      }

      if (options.type) {
        data.type = options.type;
      }

      if (options.marketingOptIn) {
        data.marketingOptIn = true;
      }

      if (options.newsletters) {
        data.newsletters = options.newsletters;
      }

      if (options.style) {
        data.style = options.style;
      }
    }

    return self.request.send(&#x27;/recovery_email/verify_code&#x27;, &#x27;POST&#x27;, null, data);
  });
};

FxAccountClient.prototype.verifyTokenCode = function(sessionToken, uid, code) {
  var self = this;

  required(uid, &#x27;uid&#x27;);
  required(code, &#x27;verify token code&#x27;);
  required(sessionToken, &#x27;sessionToken&#x27;);

  return Promise.resolve()
    .then(function() {
      return hawkCredentials(sessionToken, &#x27;sessionToken&#x27;, HKDF_SIZE);
    })
    .then(function(creds) {
      var data = {
        uid: uid,
        code: code,
      };

      return self.request.send(&#x27;/session/verify/token&#x27;, &#x27;POST&#x27;, creds, data);
    });
};

/**
 * @method recoveryEmailStatus
 * @param {String} sessionToken sessionToken obtained from signIn
 * @return {Promise} A promise that will be fulfilled with JSON &#x60;xhr.responseText&#x60; of the request
 */
FxAccountClient.prototype.recoveryEmailStatus = function(sessionToken) {
  var self = this;

  return Promise.resolve()
    .then(function() {
      required(sessionToken, &#x27;sessionToken&#x27;);

      return hawkCredentials(sessionToken, &#x27;sessionToken&#x27;, HKDF_SIZE);
    })
    .then(function(creds) {
      return self.request.send(&#x27;/recovery_email/status&#x27;, &#x27;GET&#x27;, creds);
    });
};

/**
 * Re-sends a verification code to the account&#x27;s recovery email address.
 *
 * @method recoveryEmailResendCode
 * @param {String} sessionToken sessionToken obtained from signIn
 * @param {Object} [options={}] Options
 *   @param {String} [options.email]
 *   Code will be resent to this email, only used for secondary email codes
 *   @param {String} [options.service]
 *   Opaque alphanumeric token to be included in verification links
 *   @param {String} [options.redirectTo]
 *   a URL that the client should be redirected to after handling the request
 *   @param {String} [options.resume]
 *   Opaque url-encoded string that will be included in the verification link
 *   as a querystring parameter, useful for continuing an OAuth flow for
 *   example.
 *   @param {String} [options.type]
 *   Specifies the type of code to send, currently only supported type is
 *   &#x60;upgradeSession&#x60;.
 *   @param {String} [options.lang]
 *   set the language for the &#x27;Accept-Language&#x27; header
 * @return {Promise} A promise that will be fulfilled with JSON &#x60;xhr.responseText&#x60; of the request
 */
FxAccountClient.prototype.recoveryEmailResendCode = function(
  sessionToken,
  options
) {
  var self = this;
  var data = {};
  var requestOpts = {};

  return Promise.resolve()
    .then(function() {
      required(sessionToken, &#x27;sessionToken&#x27;);

      if (options) {
        if (options.email) {
          data.email = options.email;
        }

        if (options.service) {
          data.service = options.service;
        }

        if (options.redirectTo) {
          data.redirectTo = options.redirectTo;
        }

        if (options.resume) {
          data.resume = options.resume;
        }

        if (options.type) {
          data.type = options.type;
        }

        if (options.lang) {
          requestOpts.headers = {
            &#x27;Accept-Language&#x27;: options.lang,
          };
        }

        if (options.style) {
          data.style = options.style;
        }
      }

      return hawkCredentials(sessionToken, &#x27;sessionToken&#x27;, HKDF_SIZE);
    })
    .then(function(creds) {
      return self.request.send(
        &#x27;/recovery_email/resend_code&#x27;,
        &#x27;POST&#x27;,
        creds,
        data,
        requestOpts
      );
    });
};

/**
 * Used to ask the server to send a recovery code.
 * The API returns passwordForgotToken to the client.
 *
 * @method passwordForgotSendCode
 * @param {String} email
 * @param {Object} [options={}] Options
 *   @param {String} [options.service]
 *   Opaque alphanumeric token to be included in verification links
 *   @param {String} [options.redirectTo]
 *   a URL that the client should be redirected to after handling the request
 *   @param {String} [options.resume]
 *   Opaque url-encoded string that will be included in the verification link
 *   as a querystring parameter, useful for continuing an OAuth flow for
 *   example.
 *   @param {String} [options.lang]
 *   set the language for the &#x27;Accept-Language&#x27; header
 *   @param {Object} [options.metricsContext={}] Metrics context metadata
 *     @param {String} options.metricsContext.deviceId identifier for the current device
 *     @param {String} options.metricsContext.flowId identifier for the current event flow
 *     @param {Number} options.metricsContext.flowBeginTime flow.begin event time
 *     @param {Number} options.metricsContext.utmCampaign marketing campaign identifier
 *     @param {Number} options.metricsContext.utmContent content identifier
 *     @param {Number} options.metricsContext.utmMedium acquisition medium
 *     @param {Number} options.metricsContext.utmSource traffic source
 *     @param {Number} options.metricsContext.utmTerm search terms
 * @return {Promise} A promise that will be fulfilled with JSON &#x60;xhr.responseText&#x60; of the request
 */
FxAccountClient.prototype.passwordForgotSendCode = function(email, options) {
  var self = this;
  var data = {
    email: email,
  };
  var requestOpts = {};

  return Promise.resolve().then(function() {
    required(email, &#x27;email&#x27;);

    if (options) {
      if (options.service) {
        data.service = options.service;
      }

      if (options.redirectTo) {
        data.redirectTo = options.redirectTo;
      }

      if (options.resume) {
        data.resume = options.resume;
      }

      if (options.lang) {
        requestOpts.headers = {
          &#x27;Accept-Language&#x27;: options.lang,
        };
      }

      if (options.metricsContext) {
        data.metricsContext = metricsContext.marshall(options.metricsContext);
      }
    }

    return self.request.send(
      &#x27;/password/forgot/send_code&#x27;,
      &#x27;POST&#x27;,
      null,
      data,
      requestOpts
    );
  });
};

/**
 * Re-sends a verification code to the account&#x27;s recovery email address.
 * HAWK-authenticated with the passwordForgotToken.
 *
 * @method passwordForgotResendCode
 * @param {String} email
 * @param {String} passwordForgotToken
 * @param {Object} [options={}] Options
 *   @param {String} [options.service]
 *   Opaque alphanumeric token to be included in verification links
 *   @param {String} [options.redirectTo]
 *   a URL that the client should be redirected to after handling the request
 *   @param {String} [options.resume]
 *   Opaque url-encoded string that will be included in the verification link
 *   as a querystring parameter, useful for continuing an OAuth flow for
 *   example.
 *   @param {String} [options.lang]
 *   set the language for the &#x27;Accept-Language&#x27; header
 * @return {Promise} A promise that will be fulfilled with JSON &#x60;xhr.responseText&#x60; of the request
 */
FxAccountClient.prototype.passwordForgotResendCode = function(
  email,
  passwordForgotToken,
  options
) {
  var self = this;
  var data = {
    email: email,
  };
  var requestOpts = {};

  return Promise.resolve()
    .then(function() {
      required(email, &#x27;email&#x27;);
      required(passwordForgotToken, &#x27;passwordForgotToken&#x27;);

      if (options) {
        if (options.service) {
          data.service = options.service;
        }

        if (options.redirectTo) {
          data.redirectTo = options.redirectTo;
        }

        if (options.resume) {
          data.resume = options.resume;
        }

        if (options.lang) {
          requestOpts.headers = {
            &#x27;Accept-Language&#x27;: options.lang,
          };
        }
      }

      return hawkCredentials(
        passwordForgotToken,
        &#x27;passwordForgotToken&#x27;,
        HKDF_SIZE
      );
    })
    .then(function(creds) {
      return self.request.send(
        &#x27;/password/forgot/resend_code&#x27;,
        &#x27;POST&#x27;,
        creds,
        data,
        requestOpts
      );
    });
};

/**
 * Submits the verification token to the server.
 * The API returns accountResetToken to the client.
 * HAWK-authenticated with the passwordForgotToken.
 *
 * @method passwordForgotVerifyCode
 * @param {String} code
 * @param {String} passwordForgotToken
 * @param {Object} [options={}] Options
 *   @param {Boolean} [options.accountResetWithRecoveryKey] verifying code to be use in account recovery
 * @return {Promise} A promise that will be fulfilled with JSON &#x60;xhr.responseText&#x60; of the request
 */
FxAccountClient.prototype.passwordForgotVerifyCode = function(
  code,
  passwordForgotToken,
  options
) {
  var self = this;

  return Promise.resolve()
    .then(function() {
      required(code, &#x27;reset code&#x27;);
      required(passwordForgotToken, &#x27;passwordForgotToken&#x27;);

      return hawkCredentials(
        passwordForgotToken,
        &#x27;passwordForgotToken&#x27;,
        HKDF_SIZE
      );
    })
    .then(function(creds) {
      var data = {
        code: code,
      };

      if (options &amp;&amp; options.accountResetWithRecoveryKey) {
        data.accountResetWithRecoveryKey = options.accountResetWithRecoveryKey;
      }

      return self.request.send(
        &#x27;/password/forgot/verify_code&#x27;,
        &#x27;POST&#x27;,
        creds,
        data
      );
    });
};

/**
 * Returns the status for the passwordForgotToken.
 * If the request returns a success response, the token has not yet been consumed.

 * @method passwordForgotStatus
 * @param {String} passwordForgotToken
 * @return {Promise} A promise that will be fulfilled with JSON &#x60;xhr.responseText&#x60; of the request
 */
FxAccountClient.prototype.passwordForgotStatus = function(passwordForgotToken) {
  var self = this;

  return Promise.resolve()
    .then(function() {
      required(passwordForgotToken, &#x27;passwordForgotToken&#x27;);

      return hawkCredentials(
        passwordForgotToken,
        &#x27;passwordForgotToken&#x27;,
        HKDF_SIZE
      );
    })
    .then(function(creds) {
      return self.request.send(&#x27;/password/forgot/status&#x27;, &#x27;GET&#x27;, creds);
    });
};

/**
 * The API returns reset result to the client.
 * HAWK-authenticated with accountResetToken
 *
 * @method accountReset
 * @param {String} email
 * @param {String} newPassword
 * @param {String} accountResetToken
 * @param {Object} [options={}] Options
 *   @param {Boolean} [options.keys]
 *   If &#x60;true&#x60;, a new &#x60;keyFetchToken&#x60; is provisioned. &#x60;options.sessionToken&#x60;
 *   is required if &#x60;options.keys&#x60; is true.
 *   @param {Boolean} [options.sessionToken]
 *   If &#x60;true&#x60;, a new &#x60;sessionToken&#x60; is provisioned.
 * @return {Promise} A promise that will be fulfilled with JSON &#x60;xhr.responseText&#x60; of the request
 */
FxAccountClient.prototype.accountReset = function(
  email,
  newPassword,
  accountResetToken,
  options
) {
  var self = this;
  var data = {};
  var unwrapBKey;

  options = options || {};

  if (options.sessionToken) {
    data.sessionToken = options.sessionToken;
  }

  return Promise.resolve()
    .then(function() {
      required(email, &#x27;email&#x27;);
      required(newPassword, &#x27;new password&#x27;);
      required(accountResetToken, &#x27;accountResetToken&#x27;);

      if (options.keys) {
        required(options.sessionToken, &#x27;sessionToken&#x27;);
      }

      return credentials.setup(email, newPassword);
    })
    .then(function(result) {
      if (options.keys) {
        unwrapBKey = sjcl.codec.hex.fromBits(result.unwrapBKey);
      }

      data.authPW = sjcl.codec.hex.fromBits(result.authPW);

      return hawkCredentials(accountResetToken, &#x27;accountResetToken&#x27;, HKDF_SIZE);
    })
    .then(function(creds) {
      var queryParams = &#x27;&#x27;;
      if (options.keys) {
        queryParams = &#x27;?keys=true&#x27;;
      }

      var endpoint = &#x27;/account/reset&#x27; + queryParams;
      return self.request
        .send(endpoint, &#x27;POST&#x27;, creds, data)
        .then(function(accountData) {
          if (options.keys &amp;&amp; accountData.keyFetchToken) {
            accountData.unwrapBKey = unwrapBKey;
          }

          return accountData;
        });
    });
};

/**
 * Get the base16 bundle of encrypted kA|wrapKb.
 *
 * @method accountKeys
 * @param {String} keyFetchToken
 * @param {String} oldUnwrapBKey
 * @return {Promise} A promise that will be fulfilled with JSON of {kA, kB}  of the key bundle
 */
FxAccountClient.prototype.accountKeys = function(keyFetchToken, oldUnwrapBKey) {
  var self = this;

  return Promise.resolve()
    .then(function() {
      required(keyFetchToken, &#x27;keyFetchToken&#x27;);
      required(oldUnwrapBKey, &#x27;oldUnwrapBKey&#x27;);

      return hawkCredentials(keyFetchToken, &#x27;keyFetchToken&#x27;, 3 * 32);
    })
    .then(function(creds) {
      var bundleKey = sjcl.codec.hex.fromBits(creds.bundleKey);

      return self.request
        .send(&#x27;/account/keys&#x27;, &#x27;GET&#x27;, creds)
        .then(function(payload) {
          return credentials.unbundleKeyFetchResponse(
            bundleKey,
            payload.bundle
          );
        });
    })
    .then(function(keys) {
      return {
        kB: sjcl.codec.hex.fromBits(
          credentials.xor(
            sjcl.codec.hex.toBits(keys.wrapKB),
            sjcl.codec.hex.toBits(oldUnwrapBKey)
          )
        ),
        kA: keys.kA,
      };
    });
};

/**
 * This deletes the account completely. All stored data is erased.
 *
 * @method accountDestroy
 * @param {String} email Email input
 * @param {String} password Password input
 * @param {Object} [options={}] Options
 *   @param {Boolean} [options.skipCaseError]
 *   If &#x60;true&#x60;, the request will skip the incorrect case error
 * @param {String} sessionToken User session token
 * @return {Promise} A promise that will be fulfilled with JSON &#x60;xhr.responseText&#x60; of the request
 */
FxAccountClient.prototype.accountDestroy = function(
  email,
  password,
  options,
  sessionToken
) {
  var self = this;
  options = options || {};

  return Promise.resolve()
    .then(function() {
      required(email, &#x27;email&#x27;);
      required(password, &#x27;password&#x27;);

      var defers = [credentials.setup(email, password)];
      if (sessionToken) {
        defers.push(hawkCredentials(sessionToken, &#x27;sessionToken&#x27;, HKDF_SIZE));
      }

      return Promise.all(defers);
    })
    .then(function(results) {
      var auth = results[0];
      var creds = results[1];
      var data = {
        email: auth.emailUTF8,
        authPW: sjcl.codec.hex.fromBits(auth.authPW),
      };

      return self.request.send(&#x27;/account/destroy&#x27;, &#x27;POST&#x27;, creds, data).then(
        function(response) {
          return response;
        },
        function(error) {
          // if incorrect email case error
          if (
            error &amp;&amp;
            error.email &amp;&amp;
            error.errno === ERRORS.INCORRECT_EMAIL_CASE &amp;&amp;
            !options.skipCaseError
          ) {
            options.skipCaseError = true;

            return self.accountDestroy(
              error.email,
              password,
              options,
              sessionToken
            );
          } else {
            throw error;
          }
        }
      );
    });
};

/**
 * Gets the status of an account by uid.
 *
 * @method accountStatus
 * @param {String} uid User account id
 * @return {Promise} A promise that will be fulfilled with JSON &#x60;xhr.responseText&#x60; of the request
 */
FxAccountClient.prototype.accountStatus = function(uid) {
  var self = this;

  return Promise.resolve().then(function() {
    required(uid, &#x27;uid&#x27;);

    return self.request.send(&#x27;/account/status?uid=&#x27; + uid, &#x27;GET&#x27;);
  });
};

/**
 * Gets the status of an account by email.
 *
 * @method accountStatusByEmail
 * @param {String} email User account email
 * @return {Promise} A promise that will be fulfilled with JSON &#x60;xhr.responseText&#x60; of the request
 */
FxAccountClient.prototype.accountStatusByEmail = function(email) {
  var self = this;

  return Promise.resolve().then(function() {
    required(email, &#x27;email&#x27;);

    return self.request.send(&#x27;/account/status&#x27;, &#x27;POST&#x27;, null, {
      email: email,
    });
  });
};

/**
 * Gets the account profile
 *
 * @method accountProfile
 * @param {String} sessionToken User session token
 * @return {Promise} A promise that will be fulfilled with JSON &#x60;xhr.responseText&#x60; of the request
 */
FxAccountClient.prototype.accountProfile = function(sessionToken) {
  var self = this;

  return Promise.resolve()
    .then(function() {
      required(sessionToken, &#x27;sessionToken&#x27;);

      return hawkCredentials(sessionToken, &#x27;sessionToken&#x27;, HKDF_SIZE);
    })
    .then(function(creds) {
      return self.request.send(&#x27;/account/profile&#x27;, &#x27;GET&#x27;, creds);
    });
};

/**
 * Gets aggregated account data, to be used instead of making
 * multiple calls to disparate &#x60;/status&#x60; endpoints.
 *
 * @method account
 * @param {String} sessionToken User session token
 * @return {Promise} A promise that will be fulfilled with JSON
 */
FxAccountClient.prototype.account = function(sessionToken) {
  var self = this;

  return Promise.resolve()
    .then(function() {
      required(sessionToken, &#x27;sessionToken&#x27;);

      return hawkCredentials(sessionToken, &#x27;sessionToken&#x27;, HKDF_SIZE);
    })
    .then(function(creds) {
      return self.request.send(&#x27;/account&#x27;, &#x27;GET&#x27;, creds);
    });
};

/**
 * Destroys this session, by invalidating the sessionToken.
 *
 * @method sessionDestroy
 * @param {String} sessionToken User session token
 * @param {Object} [options={}] Options
 *   @param {String} [options.customSessionToken] Override which session token to destroy for this same user
 * @return {Promise} A promise that will be fulfilled with JSON &#x60;xhr.responseText&#x60; of the request
 */
FxAccountClient.prototype.sessionDestroy = function(sessionToken, options) {
  var self = this;
  var data = {};
  options = options || {};

  if (options.customSessionToken) {
    data.customSessionToken = options.customSessionToken;
  }

  return Promise.resolve()
    .then(function() {
      required(sessionToken, &#x27;sessionToken&#x27;);

      return hawkCredentials(sessionToken, &#x27;sessionToken&#x27;, HKDF_SIZE);
    })
    .then(function(creds) {
      return self.request.send(&#x27;/session/destroy&#x27;, &#x27;POST&#x27;, creds, data);
    });
};

/**
 * Responds successfully if the session status is valid, requires the sessionToken.
 *
 * @method sessionStatus
 * @param {String} sessionToken User session token
 * @return {Promise} A promise that will be fulfilled with JSON &#x60;xhr.responseText&#x60; of the request
 */
FxAccountClient.prototype.sessionStatus = function(sessionToken) {
  var self = this;

  return Promise.resolve()
    .then(function() {
      required(sessionToken, &#x27;sessionToken&#x27;);

      return hawkCredentials(sessionToken, &#x27;sessionToken&#x27;, HKDF_SIZE);
    })
    .then(function(creds) {
      return self.request.send(&#x27;/session/status&#x27;, &#x27;GET&#x27;, creds);
    });
};

/**
 * Verifies an account and a session using a short code that is based on otp.
 *
 * @method sessionVerifyCode
 * @param {String} sessionToken User session token
 * @param {String} code Code to be verified
 * @param {Object} [options={}] Options
 *   @param {String} [options.service]
 *   Service being used
 *   @param {Boolean} [options.marketingOptIn]
 *   If &#x60;true&#x60;, notifies marketing of opt-in intent.
 *   @param {Array} [options.newsletters]
 *   Array of newsletters to opt into.
 *   @param {String} [options.style]
 *   Specify the style of email to send.
 * @return {Promise} A promise that will be fulfilled with JSON &#x60;xhr.responseText&#x60; of the request
 */
FxAccountClient.prototype.sessionVerifyCode = function(
  sessionToken,
  code,
  options
) {
  var self = this;

  required(sessionToken, &#x27;sessionToken&#x27;);
  required(code, &#x27;code&#x27;);

  var data = {
    code: code,
  };
  options = options || {};

  if (options.service) {
    data.service = options.service;
  }

  if (options.marketingOptIn) {
    data.marketingOptIn = options.marketingOptIn;
  }

  if (options.newsletters) {
    data.newsletters = options.newsletters;
  }

  if (options.style) {
    data.style = options.style;
  }

  return Promise.resolve()
    .then(function() {
      return hawkCredentials(sessionToken, &#x27;sessionToken&#x27;, HKDF_SIZE);
    })
    .then(function(creds) {
      return self.request.send(&#x27;/session/verify_code&#x27;, &#x27;POST&#x27;, creds, data);
    });
};

/**
 * Resends the short code that can verify the account and session.
 *
 * @method sessionResendVerifyCode
 * @param {String} sessionToken User session token
 * @return {Promise} A promise that will be fulfilled with JSON &#x60;xhr.responseText&#x60; of the request
 */
FxAccountClient.prototype.sessionResendVerifyCode = function(sessionToken) {
  var self = this;
  required(sessionToken, &#x27;sessionToken&#x27;);

  return Promise.resolve()
    .then(function() {
      return hawkCredentials(sessionToken, &#x27;sessionToken&#x27;, HKDF_SIZE);
    })
    .then(function(creds) {
      return self.request.send(&#x27;/session/resend_code&#x27;, &#x27;POST&#x27;, creds, {});
    });
};

/**
 * @method sessionReauth
 * @param {String} sessionToken sessionToken obtained from signIn
 * @param {String} email Email input
 * @param {String} password Password input
 * @param {Object} [options={}] Options
 *   @param {Boolean} [options.keys]
 *   If &#x60;true&#x60;, calls the API with &#x60;?keys=true&#x60; to get the keyFetchToken
 *   @param {Boolean} [options.skipCaseError]
 *   If &#x60;true&#x60;, the request will skip the incorrect case error
 *   @param {String} [options.service]
 *   Service being accessed that needs reauthentication
 *   @param {String} [options.reason]
 *   Reason for reauthentication. Can be one of: &#x60;signin&#x60;, &#x60;password_check&#x60;,
 *   &#x60;password_change&#x60;, &#x60;password_reset&#x60;
 *   @param {String} [options.redirectTo]
 *   a URL that the client should be redirected to after handling the request
 *   @param {String} [options.resume]
 *   Opaque url-encoded string that will be included in the verification link
 *   as a querystring parameter, useful for continuing an OAuth flow for
 *   example.
 *   @param {String} [options.originalLoginEmail]
 *   If retrying after an &quot;incorrect email case&quot; error, this specifies
 *   the email address as originally entered by the user.
 *   @param {String} [options.verificationMethod]
 *   Request a specific verification method be used for verifying the session,
 *   e.g. &#x27;email-2fa&#x27; or &#x27;totp-2fa&#x27;.
 *   @param {Object} [options.metricsContext={}] Metrics context metadata
 *     @param {String} options.metricsContext.deviceId identifier for the current device
 *     @param {String} options.metricsContext.flowId identifier for the current event flow
 *     @param {Number} options.metricsContext.flowBeginTime flow.begin event time
 *     @param {Number} options.metricsContext.utmCampaign marketing campaign identifier
 *     @param {Number} options.metricsContext.utmContent content identifier
 *     @param {Number} options.metricsContext.utmMedium acquisition medium
 *     @param {Number} options.metricsContext.utmSource traffic source
 *     @param {Number} options.metricsContext.utmTerm search terms
 *   @param {String} [options.unblockCode]
 *   Login unblock code.
 * @return {Promise} A promise that will be fulfilled with JSON &#x60;xhr.responseText&#x60; of the request
 */
FxAccountClient.prototype.sessionReauth = function(
  sessionToken,
  email,
  password,
  options
) {
  var self = this;
  options = options || {};

  return Promise.resolve()
    .then(function() {
      required(sessionToken, &#x27;sessionToken&#x27;);
      required(email, &#x27;email&#x27;);
      required(password, &#x27;password&#x27;);

      return credentials.setup(email, password);
    })
    .then(function(result) {
      var endpoint = &#x27;/session/reauth&#x27;;

      if (options.keys) {
        endpoint += &#x27;?keys=true&#x27;;
      }

      var data = {
        email: result.emailUTF8,
        authPW: sjcl.codec.hex.fromBits(result.authPW),
      };

      if (options.metricsContext) {
        data.metricsContext = metricsContext.marshall(options.metricsContext);
      }

      if (options.reason) {
        data.reason = options.reason;
      }

      if (options.redirectTo) {
        data.redirectTo = options.redirectTo;
      }

      if (options.resume) {
        data.resume = options.resume;
      }

      if (options.service) {
        data.service = options.service;
      }

      if (options.unblockCode) {
        data.unblockCode = options.unblockCode;
      }

      if (options.originalLoginEmail) {
        data.originalLoginEmail = options.originalLoginEmail;
      }

      if (options.verificationMethod) {
        data.verificationMethod = options.verificationMethod;
      }

      return hawkCredentials(sessionToken, &#x27;sessionToken&#x27;, HKDF_SIZE)
        .then(function(creds) {
          return self.request.send(endpoint, &#x27;POST&#x27;, creds, data);
        })
        .then(
          function(accountData) {
            if (options.keys) {
              accountData.unwrapBKey = sjcl.codec.hex.fromBits(
                result.unwrapBKey
              );
            }
            return accountData;
          },
          function(error) {
            if (
              error &amp;&amp;
              error.email &amp;&amp;
              error.errno === ERRORS.INCORRECT_EMAIL_CASE &amp;&amp;
              !options.skipCaseError
            ) {
              options.skipCaseError = true;
              options.originalLoginEmail = email;

              return self.sessionReauth(
                sessionToken,
                error.email,
                password,
                options
              );
            } else {
              throw error;
            }
          }
        );
    });
};

/**
 * Sign a BrowserID public key
 *
 * @method certificateSign
 * @param {String} sessionToken User session token
 * @param {Object} publicKey The key to sign
 * @param {int} duration Time interval from now when the certificate will expire in milliseconds
 * @param {Object} [options={}] Options
 *   @param {String} [service=&#x27;&#x27;] The requesting service, sent via the query string
 * @return {Promise} A promise that will be fulfilled with JSON &#x60;xhr.responseText&#x60; of the request
 */
FxAccountClient.prototype.certificateSign = function(
  sessionToken,
  publicKey,
  duration,
  options
) {
  var self = this;
  var data = {
    publicKey: publicKey,
    duration: duration,
  };

  return Promise.resolve()
    .then(function() {
      required(sessionToken, &#x27;sessionToken&#x27;);
      required(publicKey, &#x27;publicKey&#x27;);
      required(duration, &#x27;duration&#x27;);

      return hawkCredentials(sessionToken, &#x27;sessionToken&#x27;, HKDF_SIZE);
    })
    .then(function(creds) {
      options = options || {};

      var queryString = &#x27;&#x27;;
      if (options.service) {
        queryString = &#x27;?service=&#x27; + encodeURIComponent(options.service);
      }

      return self.request.send(
        &#x27;/certificate/sign&#x27; + queryString,
        &#x27;POST&#x27;,
        creds,
        data
      );
    });
};

/**
 * Change the password from one known value to another.
 *
 * @method passwordChange
 * @param {String} email
 * @param {String} oldPassword
 * @param {String} newPassword
 * @param {Object} [options={}] Options
 *   @param {Boolean} [options.keys]
 *   If &#x60;true&#x60;, calls the API with &#x60;?keys=true&#x60; to get a new keyFetchToken
 *   @param {String} [options.sessionToken]
 *   If a &#x60;sessionToken&#x60; is passed, a new sessionToken will be returned
 *   with the same &#x60;verified&#x60; status as the existing sessionToken.
 * @return {Promise} A promise that will be fulfilled with JSON &#x60;xhr.responseText&#x60; of the request
 */
FxAccountClient.prototype.passwordChange = function(
  email,
  oldPassword,
  newPassword,
  options
) {
  var self = this;
  options = options || {};

  return Promise.resolve()
    .then(function() {
      required(email, &#x27;email&#x27;);
      required(oldPassword, &#x27;old password&#x27;);
      required(newPassword, &#x27;new password&#x27;);

      return self._passwordChangeStart(email, oldPassword);
    })
    .then(function(credentials) {
      var oldCreds = credentials;
      var emailToHashWith = credentials.emailToHashWith || email;

      return self._passwordChangeKeys(oldCreds).then(function(keys) {
        return self._passwordChangeFinish(
          emailToHashWith,
          newPassword,
          oldCreds,
          keys,
          options
        );
      });
    });
};

/**
 * First step to change the password.
 *
 * @method passwordChangeStart
 * @private
 * @param {String} email
 * @param {String} oldPassword
 * @param {Object} [options={}] Options
 *   @param {Boolean} [options.skipCaseError]
 *   If &#x60;true&#x60;, the request will skip the incorrect case error
 * @return {Promise} A promise that will be fulfilled with JSON of &#x60;xhr.responseText&#x60; and &#x60;oldUnwrapBKey&#x60;
 */
FxAccountClient.prototype._passwordChangeStart = function(
  email,
  oldPassword,
  options
) {
  var self = this;
  options = options || {};

  return Promise.resolve()
    .then(function() {
      required(email, &#x27;email&#x27;);
      required(oldPassword, &#x27;old password&#x27;);

      return credentials.setup(email, oldPassword);
    })
    .then(function(oldCreds) {
      var data = {
        email: oldCreds.emailUTF8,
        oldAuthPW: sjcl.codec.hex.fromBits(oldCreds.authPW),
      };

      return self.request
        .send(&#x27;/password/change/start&#x27;, &#x27;POST&#x27;, null, data)
        .then(
          function(passwordData) {
            passwordData.oldUnwrapBKey = sjcl.codec.hex.fromBits(
              oldCreds.unwrapBKey
            );

            // Similar to password reset, this keeps the contract that we always
            // hash passwords with the original account email.
            passwordData.emailToHashWith = email;
            return passwordData;
          },
          function(error) {
            // if incorrect email case error
            if (
              error &amp;&amp;
              error.email &amp;&amp;
              error.errno === ERRORS.INCORRECT_EMAIL_CASE &amp;&amp;
              !options.skipCaseError
            ) {
              options.skipCaseError = true;

              return self._passwordChangeStart(
                error.email,
                oldPassword,
                options
              );
            } else {
              throw error;
            }
          }
        );
    });
};

function checkCreds(creds) {
  required(creds, &#x27;credentials&#x27;);
  required(creds.oldUnwrapBKey, &#x27;credentials.oldUnwrapBKey&#x27;);
  required(creds.keyFetchToken, &#x27;credentials.keyFetchToken&#x27;);
  required(creds.passwordChangeToken, &#x27;credentials.passwordChangeToken&#x27;);
}

/**
 * Second step to change the password.
 *
 * @method _passwordChangeKeys
 * @private
 * @param {Object} oldCreds This object should consists of &#x60;oldUnwrapBKey&#x60;, &#x60;keyFetchToken&#x60; and &#x60;passwordChangeToken&#x60;.
 * @return {Promise} A promise that will be fulfilled with JSON of &#x60;xhr.responseText&#x60;
 */
FxAccountClient.prototype._passwordChangeKeys = function(oldCreds) {
  var self = this;

  return Promise.resolve()
    .then(function() {
      checkCreds(oldCreds);
    })
    .then(function() {
      return self.accountKeys(oldCreds.keyFetchToken, oldCreds.oldUnwrapBKey);
    });
};

/**
 * Third step to change the password.
 *
 * @method _passwordChangeFinish
 * @private
 * @param {String} email
 * @param {String} newPassword
 * @param {Object} oldCreds This object should consists of &#x60;oldUnwrapBKey&#x60;, &#x60;keyFetchToken&#x60; and &#x60;passwordChangeToken&#x60;.
 * @param {Object} keys This object should contain the unbundled keys
 * @param {Object} [options={}] Options
 *   @param {Boolean} [options.keys]
 *   If &#x60;true&#x60;, calls the API with &#x60;?keys=true&#x60; to get the keyFetchToken
 *   @param {String} [options.sessionToken]
 *   If a &#x60;sessionToken&#x60; is passed, a new sessionToken will be returned
 *   with the same &#x60;verified&#x60; status as the existing sessionToken.
 * @return {Promise} A promise that will be fulfilled with JSON of &#x60;xhr.responseText&#x60;
 */
FxAccountClient.prototype._passwordChangeFinish = function(
  email,
  newPassword,
  oldCreds,
  keys,
  options
) {
  options = options || {};
  var self = this;

  return Promise.resolve()
    .then(function() {
      required(email, &#x27;email&#x27;);
      required(newPassword, &#x27;new password&#x27;);
      checkCreds(oldCreds);
      required(keys, &#x27;keys&#x27;);
      required(keys.kB, &#x27;keys.kB&#x27;);

      var defers = [];
      defers.push(credentials.setup(email, newPassword));
      defers.push(
        hawkCredentials(
          oldCreds.passwordChangeToken,
          &#x27;passwordChangeToken&#x27;,
          HKDF_SIZE
        )
      );

      if (options.sessionToken) {
        // Unbundle session data to get session id
        defers.push(
          hawkCredentials(options.sessionToken, &#x27;sessionToken&#x27;, HKDF_SIZE)
        );
      }

      return Promise.all(defers);
    })
    .then(function(results) {
      var newCreds = results[0];
      var hawkCreds = results[1];
      var sessionData = results[2];
      var newWrapKb = sjcl.codec.hex.fromBits(
        credentials.xor(sjcl.codec.hex.toBits(keys.kB), newCreds.unwrapBKey)
      );

      var queryParams = &#x27;&#x27;;
      if (options.keys) {
        queryParams = &#x27;?keys=true&#x27;;
      }

      var sessionTokenId;
      if (sessionData &amp;&amp; sessionData.id) {
        sessionTokenId = sessionData.id;
      }

      return self.request
        .send(&#x27;/password/change/finish&#x27; + queryParams, &#x27;POST&#x27;, hawkCreds, {
          wrapKb: newWrapKb,
          authPW: sjcl.codec.hex.fromBits(newCreds.authPW),
          sessionToken: sessionTokenId,
        })
        .then(function(accountData) {
          if (options.keys &amp;&amp; accountData.keyFetchToken) {
            accountData.unwrapBKey = sjcl.codec.hex.fromBits(
              newCreds.unwrapBKey
            );
          }
          return accountData;
        });
    });
};

/**
 * Get 32 bytes of random data. This should be combined with locally-sourced entropy when creating salts, etc.
 *
 * @method getRandomBytes
 * @return {Promise} A promise that will be fulfilled with JSON &#x60;xhr.responseText&#x60; of the request
 */
FxAccountClient.prototype.getRandomBytes = function() {
  return this.request.send(&#x27;/get_random_bytes&#x27;, &#x27;POST&#x27;);
};

/**
 * Add a new device
 *
 * @method deviceRegister
 * @param {String} sessionToken User session token
 * @param {String} deviceName Name of device
 * @param {String} deviceType Type of device (mobile|desktop)
 * @param {Object} [options={}] Options
 *   @param {string} [options.deviceCallback] Device&#x27;s push endpoint.
 *   @param {string} [options.devicePublicKey] Public key used to encrypt push messages.
 *   @param {string} [options.deviceAuthKey] Authentication secret used to encrypt push messages.
 * @return {Promise} A promise that will be fulfilled with JSON &#x60;xhr.responseText&#x60; of the request
 */
FxAccountClient.prototype.deviceRegister = function(
  sessionToken,
  deviceName,
  deviceType,
  options
) {
  var request = this.request;
  options = options || {};

  return Promise.resolve()
    .then(function() {
      required(sessionToken, &#x27;sessionToken&#x27;);
      required(deviceName, &#x27;deviceName&#x27;);
      required(deviceType, &#x27;deviceType&#x27;);

      return hawkCredentials(sessionToken, &#x27;sessionToken&#x27;, HKDF_SIZE);
    })
    .then(function(creds) {
      var data = {
        name: deviceName,
        type: deviceType,
      };

      if (options.deviceCallback) {
        data.pushCallback = options.deviceCallback;
      }

      if (options.devicePublicKey &amp;&amp; options.deviceAuthKey) {
        data.pushPublicKey = options.devicePublicKey;
        data.pushAuthKey = options.deviceAuthKey;
      }

      return request.send(&#x27;/account/device&#x27;, &#x27;POST&#x27;, creds, data);
    });
};

/**
 * Update the name of an existing device
 *
 * @method deviceUpdate
 * @param {String} sessionToken User session token
 * @param {String} deviceId User-unique identifier of device
 * @param {String} deviceName Name of device
 * @param {Object} [options={}] Options
 *   @param {string} [options.deviceCallback] Device&#x27;s push endpoint.
 *   @param {string} [options.devicePublicKey] Public key used to encrypt push messages.
 *   @param {string} [options.deviceAuthKey] Authentication secret used to encrypt push messages.
 * @return {Promise} A promise that will be fulfilled with JSON &#x60;xhr.responseText&#x60; of the request
 */
FxAccountClient.prototype.deviceUpdate = function(
  sessionToken,
  deviceId,
  deviceName,
  options
) {
  var request = this.request;
  options = options || {};

  return Promise.resolve()
    .then(function() {
      required(sessionToken, &#x27;sessionToken&#x27;);
      required(deviceId, &#x27;deviceId&#x27;);
      required(deviceName, &#x27;deviceName&#x27;);

      return hawkCredentials(sessionToken, &#x27;sessionToken&#x27;, HKDF_SIZE);
    })
    .then(function(creds) {
      var data = {
        id: deviceId,
        name: deviceName,
      };

      if (options.deviceCallback) {
        data.pushCallback = options.deviceCallback;
      }

      if (options.devicePublicKey &amp;&amp; options.deviceAuthKey) {
        data.pushPublicKey = options.devicePublicKey;
        data.pushAuthKey = options.deviceAuthKey;
      }

      return request.send(&#x27;/account/device&#x27;, &#x27;POST&#x27;, creds, data);
    });
};

/**
 * Unregister an existing device
 *
 * @method deviceDestroy
 * @param {String} sessionToken Session token obtained from signIn
 * @param {String} deviceId User-unique identifier of device
 * @return {Promise} A promise that will be fulfilled with JSON &#x60;xhr.responseText&#x60; of the request
 */
FxAccountClient.prototype.deviceDestroy = function(sessionToken, deviceId) {
  var request = this.request;

  return Promise.resolve()
    .then(function() {
      required(sessionToken, &#x27;sessionToken&#x27;);
      required(deviceId, &#x27;deviceId&#x27;);

      return hawkCredentials(sessionToken, &#x27;sessionToken&#x27;, HKDF_SIZE);
    })
    .then(function(creds) {
      var data = {
        id: deviceId,
      };

      return request.send(&#x27;/account/device/destroy&#x27;, &#x27;POST&#x27;, creds, data);
    });
};

/**
 * Get a list of all devices for a user
 *
 * @method deviceList
 * @param {String} sessionToken sessionToken obtained from signIn
 * @return {Promise} A promise that will be fulfilled with JSON &#x60;xhr.responseText&#x60; of the request
 */
FxAccountClient.prototype.deviceList = function(sessionToken) {
  var request = this.request;

  return Promise.resolve()
    .then(function() {
      required(sessionToken, &#x27;sessionToken&#x27;);

      return hawkCredentials(sessionToken, &#x27;sessionToken&#x27;, HKDF_SIZE);
    })
    .then(function(creds) {
      return request.send(&#x27;/account/devices&#x27;, &#x27;GET&#x27;, creds);
    });
};

/**
 * Get a list of user&#x27;s sessions
 *
 * @method sessions
 * @param {String} sessionToken sessionToken obtained from signIn
 * @return {Promise} A promise that will be fulfilled with JSON &#x60;xhr.responseText&#x60; of the request
 */
FxAccountClient.prototype.sessions = function(sessionToken) {
  var request = this.request;

  return Promise.resolve()
    .then(function() {
      required(sessionToken, &#x27;sessionToken&#x27;);

      return hawkCredentials(sessionToken, &#x27;sessionToken&#x27;, HKDF_SIZE);
    })
    .then(function(creds) {
      return request.send(&#x27;/account/sessions&#x27;, &#x27;GET&#x27;, creds);
    });
};

/**
 * Get a list of user&#x27;s security events
 *
 * @method securityEvents
 * @param {String} sessionToken sessionToken obtained from signIn
 * @return {Promise} A promise that will be fulfilled with JSON &#x60;xhr.responseText&#x60; of the request
 */
FxAccountClient.prototype.securityEvents = function(sessionToken) {
  var request = this.request;

  return Promise.resolve()
    .then(function() {
      required(sessionToken, &#x27;sessionToken&#x27;);

      return hawkCredentials(sessionToken, &#x27;sessionToken&#x27;, HKDF_SIZE);
    })
    .then(function(creds) {
      return request.send(&#x27;/securityEvents&#x27;, &#x27;GET&#x27;, creds);
    });
};

/**
 * Delete user&#x27;s security events
 *
 * @method deleteSecurityEvents
 * @param {String} sessionToken sessionToken obtained from signIn
 * @return {Promise} A promise that will be fulfilled with JSON &#x60;xhr.responseText&#x60; of the request
 */
FxAccountClient.prototype.deleteSecurityEvents = function(sessionToken) {
  var request = this.request;

  return Promise.resolve()
    .then(function() {
      required(sessionToken, &#x27;sessionToken&#x27;);

      return hawkCredentials(sessionToken, &#x27;sessionToken&#x27;, HKDF_SIZE);
    })
    .then(function(creds) {
      return request.send(&#x27;/securityEvents&#x27;, &#x27;DELETE&#x27;, creds, {});
    });
};

/**
 * Get a list of user&#x27;s attached clients
 *
 * @method attachedClients
 * @param {String} sessionToken sessionToken obtained from signIn
 * @return {Promise} A promise that will be fulfilled with JSON &#x60;xhr.responseText&#x60; of the request
 */
FxAccountClient.prototype.attachedClients = function(sessionToken) {
  var request = this.request;

  return Promise.resolve()
    .then(function() {
      required(sessionToken, &#x27;sessionToken&#x27;);

      return hawkCredentials(sessionToken, &#x27;sessionToken&#x27;, HKDF_SIZE);
    })
    .then(function(creds) {
      return request.send(&#x27;/account/attached_clients&#x27;, &#x27;GET&#x27;, creds);
    });
};

/**
 * Destroys all tokens held by an attached client.
 *
 * @method attachedClientDestroy
 * @param {String} sessionToken User session token
 * @param {Object} clientInfo Attached client info, as returned by &#x60;attachedClients&#x60; method
 * @return {Promise} A promise that will be fulfilled with JSON &#x60;xhr.responseText&#x60; of the request
 */
FxAccountClient.prototype.attachedClientDestroy = function(
  sessionToken,
  clientInfo
) {
  var self = this;
  var data = {
    clientId: clientInfo.clientId,
    deviceId: clientInfo.deviceId,
    refreshTokenId: clientInfo.refreshTokenId,
    sessionTokenId: clientInfo.sessionTokenId,
  };

  return Promise.resolve()
    .then(function() {
      required(sessionToken, &#x27;sessionToken&#x27;);

      return hawkCredentials(sessionToken, &#x27;sessionToken&#x27;, HKDF_SIZE);
    })
    .then(function(creds) {
      return self.request.send(
        &#x27;/account/attached_client/destroy&#x27;,
        &#x27;POST&#x27;,
        creds,
        data
      );
    });
};

/**
 * Get a list of user&#x27;s attached clients
 *
 * @method attachedClients
 * @param {String} sessionToken sessionToken obtained from signIn
 * @return {Promise} A promise that will be fulfilled with JSON &#x60;xhr.responseText&#x60; of the request
 */
FxAccountClient.prototype.attachedClients = function(sessionToken) {
  var request = this.request;

  return Promise.resolve()
    .then(function() {
      required(sessionToken, &#x27;sessionToken&#x27;);

      return hawkCredentials(sessionToken, &#x27;sessionToken&#x27;, HKDF_SIZE);
    })
    .then(function(creds) {
      return request.send(&#x27;/account/attached_clients&#x27;, &#x27;GET&#x27;, creds);
    });
};

/**
 * Destroys all tokens held by an attached client.
 *
 * @method attachedClientDestroy
 * @param {String} sessionToken User session token
 * @param {Object} clientInfo Attached client info, as returned by &#x60;attachedClients&#x60; method
 * @return {Promise} A promise that will be fulfilled with JSON &#x60;xhr.responseText&#x60; of the request
 */
FxAccountClient.prototype.attachedClientDestroy = function(
  sessionToken,
  clientInfo
) {
  var self = this;
  var data = {
    clientId: clientInfo.clientId,
    deviceId: clientInfo.deviceId,
    refreshTokenId: clientInfo.refreshTokenId,
    sessionTokenId: clientInfo.sessionTokenId,
  };

  return Promise.resolve()
    .then(function() {
      required(sessionToken, &#x27;sessionToken&#x27;);

      return hawkCredentials(sessionToken, &#x27;sessionToken&#x27;, HKDF_SIZE);
    })
    .then(function(creds) {
      return self.request.send(
        &#x27;/account/attached_client/destroy&#x27;,
        &#x27;POST&#x27;,
        creds,
        data
      );
    });
};

/**
 * Send an unblock code
 *
 * @method sendUnblockCode
 * @param {String} email email where to send the login authorization code
 * @param {Object} [options={}] Options
 *   @param {Object} [options.metricsContext={}] Metrics context metadata
 *     @param {String} options.metricsContext.deviceId identifier for the current device
 *     @param {String} options.metricsContext.flowId identifier for the current event flow
 *     @param {Number} options.metricsContext.flowBeginTime flow.begin event time
 *     @param {Number} options.metricsContext.utmCampaign marketing campaign identifier
 *     @param {Number} options.metricsContext.utmContent content identifier
 *     @param {Number} options.metricsContext.utmMedium acquisition medium
 *     @param {Number} options.metricsContext.utmSource traffic source
 *     @param {Number} options.metricsContext.utmTerm search terms
 * @return {Promise} A promise that will be fulfilled with JSON &#x60;xhr.responseText&#x60; of the request
 */
FxAccountClient.prototype.sendUnblockCode = function(email, options) {
  var self = this;

  return Promise.resolve().then(function() {
    required(email, &#x27;email&#x27;);

    var data = {
      email: email,
    };

    if (options &amp;&amp; options.metricsContext) {
      data.metricsContext = metricsContext.marshall(options.metricsContext);
    }

    return self.request.send(
      &#x27;/account/login/send_unblock_code&#x27;,
      &#x27;POST&#x27;,
      null,
      data
    );
  });
};

/**
 * Reject a login unblock code. Code will be deleted from the server
 * and will not be able to be used again.
 *
 * @method rejectLoginAuthorizationCode
 * @param {String} uid Account ID
 * @param {String} unblockCode unblock code
 * @return {Promise} A promise that will be fulfilled with JSON &#x60;xhr.responseText&#x60; of the request
 */
FxAccountClient.prototype.rejectUnblockCode = function(uid, unblockCode) {
  var self = this;

  return Promise.resolve().then(function() {
    required(uid, &#x27;uid&#x27;);
    required(unblockCode, &#x27;unblockCode&#x27;);

    var data = {
      uid: uid,
      unblockCode: unblockCode,
    };

    return self.request.send(
      &#x27;/account/login/reject_unblock_code&#x27;,
      &#x27;POST&#x27;,
      null,
      data
    );
  });
};

/**
 * Send an sms.
 *
 * @method sendSms
 * @param {String} sessionToken SessionToken obtained from signIn
 * @param {String} phoneNumber Phone number sms will be sent to
 * @param {String} messageId Corresponding message id that will be sent
 * @param {Object} [options={}] Options
 *   @param {String} [options.lang] Language that sms will be sent in
 *   @param {Array} [options.features] Array of features to be enabled for the request
 *   @param {Object} [options.metricsContext={}] Metrics context metadata
 *     @param {String} options.metricsContext.deviceId identifier for the current device
 *     @param {String} options.metricsContext.flowId identifier for the current event flow
 *     @param {Number} options.metricsContext.flowBeginTime flow.begin event time
 *     @param {Number} options.metricsContext.utmCampaign marketing campaign identifier
 *     @param {Number} options.metricsContext.utmContent content identifier
 *     @param {Number} options.metricsContext.utmMedium acquisition medium
 *     @param {Number} options.metricsContext.utmSource traffic source
 *     @param {Number} options.metricsContext.utmTerm search terms
 */
FxAccountClient.prototype.sendSms = function(
  sessionToken,
  phoneNumber,
  messageId,
  options
) {
  var request = this.request;

  return Promise.resolve()
    .then(function() {
      required(sessionToken, &#x27;sessionToken&#x27;);
      required(phoneNumber, &#x27;phoneNumber&#x27;);
      required(messageId, &#x27;messageId&#x27;);

      return hawkCredentials(sessionToken, &#x27;sessionToken&#x27;, HKDF_SIZE);
    })
    .then(function(creds) {
      var data = {
        phoneNumber: phoneNumber,
        messageId: messageId,
      };
      var requestOpts = {};

      if (options) {
        if (options.lang) {
          requestOpts.headers = {
            &#x27;Accept-Language&#x27;: options.lang,
          };
        }

        if (options.features) {
          data.features = options.features;
        }

        if (options.metricsContext) {
          data.metricsContext = metricsContext.marshall(options.metricsContext);
        }
      }

      return request.send(&#x27;/sms&#x27;, &#x27;POST&#x27;, creds, data, requestOpts);
    });
};

/**
 * Get SMS status for the current user.
 *
 * @method smsStatus
 * @param {String} sessionToken SessionToken obtained from signIn
 * @param {Object} [options={}] Options
 *   @param {String} [options.country] country Country to force for testing.
 */
FxAccountClient.prototype.smsStatus = function(sessionToken, options) {
  var request = this.request;
  options = options || {};

  return Promise.resolve()
    .then(function() {
      required(sessionToken, &#x27;sessionToken&#x27;);

      return hawkCredentials(sessionToken, &#x27;sessionToken&#x27;, HKDF_SIZE);
    })
    .then(function(creds) {
      var url = &#x27;/sms/status&#x27;;
      if (options.country) {
        url += &#x27;?country=&#x27; + encodeURIComponent(options.country);
      }
      return request.send(url, &#x27;GET&#x27;, creds);
    });
};

/**
 * Consume a signinCode.
 *
 * @method consumeSigninCode
 * @param {String} code The signinCode entered by the user
 * @param {String} flowId Identifier for the current event flow
 * @param {Number} flowBeginTime Timestamp for the flow.begin event
 * @param {String} [deviceId] Identifier for the current device
 */
FxAccountClient.prototype.consumeSigninCode = function(
  code,
  flowId,
  flowBeginTime,
  deviceId
) {
  var self = this;

  return Promise.resolve().then(function() {
    required(code, &#x27;code&#x27;);
    required(flowId, &#x27;flowId&#x27;);
    required(flowBeginTime, &#x27;flowBeginTime&#x27;);

    return self.request.send(&#x27;/signinCodes/consume&#x27;, &#x27;POST&#x27;, null, {
      code: code,
      metricsContext: {
        deviceId: deviceId,
        flowId: flowId,
        flowBeginTime: flowBeginTime,
      },
    });
  });
};

/**
 * Get the recovery emails associated with the signed in account.
 *
 * @method recoveryEmails
 * @param {String} sessionToken SessionToken obtained from signIn
 */
FxAccountClient.prototype.recoveryEmails = function(sessionToken) {
  var request = this.request;

  return Promise.resolve()
    .then(function() {
      required(sessionToken, &#x27;sessionToken&#x27;);

      return hawkCredentials(sessionToken, &#x27;sessionToken&#x27;, HKDF_SIZE);
    })
    .then(function(creds) {
      return request.send(&#x27;/recovery_emails&#x27;, &#x27;GET&#x27;, creds);
    });
};

/**
 * Create a new recovery email for the signed in account.
 *
 * @method recoveryEmailCreate
 * @param {String} sessionToken SessionToken obtained from signIn
 * @param {String} email new email to be added
 */
FxAccountClient.prototype.recoveryEmailCreate = function(sessionToken, email) {
  var request = this.request;

  return Promise.resolve()
    .then(function() {
      required(sessionToken, &#x27;sessionToken&#x27;);
      required(sessionToken, &#x27;email&#x27;);

      return hawkCredentials(sessionToken, &#x27;sessionToken&#x27;, HKDF_SIZE);
    })
    .then(function(creds) {
      var data = {
        email: email,
      };

      return request.send(&#x27;/recovery_email&#x27;, &#x27;POST&#x27;, creds, data);
    });
};

/**
 * Remove the recovery email for the signed in account.
 *
 * @method recoveryEmailDestroy
 * @param {String} sessionToken SessionToken obtained from signIn
 * @param {String} email email to be removed
 */
FxAccountClient.prototype.recoveryEmailDestroy = function(sessionToken, email) {
  var request = this.request;

  return Promise.resolve()
    .then(function() {
      required(sessionToken, &#x27;sessionToken&#x27;);
      required(sessionToken, &#x27;email&#x27;);

      return hawkCredentials(sessionToken, &#x27;sessionToken&#x27;, HKDF_SIZE);
    })
    .then(function(creds) {
      var data = {
        email: email,
      };

      return request.send(&#x27;/recovery_email/destroy&#x27;, &#x27;POST&#x27;, creds, data);
    });
};

/**
 * Changes user&#x27;s primary email address.
 *
 * @method recoveryEmailSetPrimaryEmail
 * @param {String} sessionToken SessionToken obtained from signIn
 * @param {String} email Email that will be the new primary email for user
 */
FxAccountClient.prototype.recoveryEmailSetPrimaryEmail = function(
  sessionToken,
  email
) {
  var request = this.request;
  return Promise.resolve()
    .then(function() {
      required(sessionToken, &#x27;sessionToken&#x27;);

      return hawkCredentials(sessionToken, &#x27;sessionToken&#x27;, HKDF_SIZE);
    })
    .then(function(creds) {
      var data = {
        email: email,
      };
      return request.send(&#x27;/recovery_email/set_primary&#x27;, &#x27;POST&#x27;, creds, data);
    });
};

/**
 * Creates a new TOTP token for the user associated with this session.
 *
 * @method createTotpToken
 * @param {String} sessionToken SessionToken obtained from signIn
 * @param {Object} [options.metricsContext={}] Metrics context metadata
 *   @param {String} options.metricsContext.deviceId identifier for the current device
 *   @param {String} options.metricsContext.flowId identifier for the current event flow
 *   @param {Number} options.metricsContext.flowBeginTime flow.begin event time
 *   @param {Number} options.metricsContext.utmCampaign marketing campaign identifier
 *   @param {Number} options.metricsContext.utmContent content identifier
 *   @param {Number} options.metricsContext.utmMedium acquisition medium
 *   @param {Number} options.metricsContext.utmSource traffic source
 *   @param {Number} options.metricsContext.utmTerm search terms
 */
FxAccountClient.prototype.createTotpToken = function(sessionToken, options) {
  var request = this.request;
  return Promise.resolve()
    .then(function() {
      required(sessionToken, &#x27;sessionToken&#x27;);

      return hawkCredentials(sessionToken, &#x27;sessionToken&#x27;, HKDF_SIZE);
    })
    .then(function(creds) {
      var data = {};

      if (options &amp;&amp; options.metricsContext) {
        data.metricsContext = metricsContext.marshall(options.metricsContext);
      }

      return request.send(&#x27;/totp/create&#x27;, &#x27;POST&#x27;, creds, data);
    });
};

/**
 * Deletes this user&#x27;s TOTP token.
 *
 * @method deleteTotpToken
 * @param {String} sessionToken SessionToken obtained from signIn
 */
FxAccountClient.prototype.deleteTotpToken = function(sessionToken) {
  var request = this.request;
  return Promise.resolve()
    .then(function() {
      required(sessionToken, &#x27;sessionToken&#x27;);

      return hawkCredentials(sessionToken, &#x27;sessionToken&#x27;, HKDF_SIZE);
    })
    .then(function(creds) {
      return request.send(&#x27;/totp/destroy&#x27;, &#x27;POST&#x27;, creds, {});
    });
};

/**
 * Check to see if the current user has a TOTP token associated with
 * their account.
 *
 * @method checkTotpTokenExists
 * @param {String} sessionToken SessionToken obtained from signIn
 */
FxAccountClient.prototype.checkTotpTokenExists = function(sessionToken) {
  var request = this.request;
  return Promise.resolve()
    .then(function() {
      required(sessionToken, &#x27;sessionToken&#x27;);

      return hawkCredentials(sessionToken, &#x27;sessionToken&#x27;, HKDF_SIZE);
    })
    .then(function(creds) {
      return request.send(&#x27;/totp/exists&#x27;, &#x27;GET&#x27;, creds);
    });
};

/**
 * Verify tokens if using a valid TOTP code.
 *
 * @method verifyTotpCode
 * @param {String} sessionToken SessionToken obtained from signIn
 * @param {String} code TOTP code to verif
 * @param {String} [options.service] Service being used
 */
FxAccountClient.prototype.verifyTotpCode = function(
  sessionToken,
  code,
  options
) {
  var request = this.request;
  return Promise.resolve()
    .then(function() {
      required(sessionToken, &#x27;sessionToken&#x27;);
      required(code, &#x27;code&#x27;);

      return hawkCredentials(sessionToken, &#x27;sessionToken&#x27;, HKDF_SIZE);
    })
    .then(function(creds) {
      var data = {
        code: code,
      };

      if (options &amp;&amp; options.service) {
        data.service = options.service;
      }

      return request.send(&#x27;/session/verify/totp&#x27;, &#x27;POST&#x27;, creds, data);
    });
};

/**
 * Replace user&#x27;s recovery codes.
 *
 * @method replaceRecoveryCodes
 * @param {String} sessionToken SessionToken obtained from signIn
 */
FxAccountClient.prototype.replaceRecoveryCodes = function(sessionToken) {
  var request = this.request;
  return Promise.resolve()
    .then(function() {
      required(sessionToken, &#x27;sessionToken&#x27;);

      return hawkCredentials(sessionToken, &#x27;sessionToken&#x27;, HKDF_SIZE);
    })
    .then(function(creds) {
      return request.send(&#x27;/recoveryCodes&#x27;, &#x27;GET&#x27;, creds);
    });
};

/**
 * Consume recovery code.
 *
 * @method consumeRecoveryCode
 * @param {String} sessionToken SessionToken obtained from signIn
 * @param {String} code recovery code
 */
FxAccountClient.prototype.consumeRecoveryCode = function(sessionToken, code) {
  var request = this.request;
  return Promise.resolve()
    .then(function() {
      required(sessionToken, &#x27;sessionToken&#x27;);
      required(code, &#x27;code&#x27;);

      return hawkCredentials(sessionToken, &#x27;sessionToken&#x27;, HKDF_SIZE);
    })
    .then(function(creds) {
      var data = {
        code: code,
      };

      return request.send(&#x27;/session/verify/recoveryCode&#x27;, &#x27;POST&#x27;, creds, data);
    });
};

/**
 * Creates a new recovery key for the account. The recovery key contains encrypted
 * data the corresponds the the accounts current &#x60;kB&#x60;. This data can be used during
 * the password reset process to avoid regenerating the &#x60;kB&#x60;.
 *
 * @param sessionToken
 * @param recoveryKeyId The recoveryKeyId that can be used to retrieve saved bundle
 * @param bundle The encrypted recovery bundle to store
 * @returns {Promise} A promise that will be fulfilled with decoded recovery data (&#x60;kB&#x60;)
 */
FxAccountClient.prototype.createRecoveryKey = function(
  sessionToken,
  recoveryKeyId,
  bundle
) {
  var request = this.request;
  return Promise.resolve()
    .then(function() {
      required(sessionToken, &#x27;sessionToken&#x27;);
      required(recoveryKeyId, &#x27;recoveryKeyId&#x27;);
      required(bundle, &#x27;bundle&#x27;);

      return hawkCredentials(sessionToken, &#x27;sessionToken&#x27;, HKDF_SIZE);
    })
    .then(function(creds) {
      var data = {
        recoveryKeyId: recoveryKeyId,
        recoveryData: bundle,
      };

      return request.send(&#x27;/recoveryKey&#x27;, &#x27;POST&#x27;, creds, data);
    });
};

/**
 * Retrieves the encrypted recovery data that corresponds to the recovery key which
 * then gets decoded into the stored &#x60;kB&#x60;.
 *
 * @param accountResetToken
 * @param recoveryKeyId The recovery key id to retrieve encrypted bundle
 * @returns {Promise} A promise that will be fulfilled with decoded recovery data (&#x60;kB&#x60;)
 */
FxAccountClient.prototype.getRecoveryKey = function(
  accountResetToken,
  recoveryKeyId
) {
  var request = this.request;
  return Promise.resolve()
    .then(function() {
      required(accountResetToken, &#x27;accountResetToken&#x27;);
      required(recoveryKeyId, &#x27;recoveryKeyId&#x27;);

      return hawkCredentials(accountResetToken, &#x27;accountResetToken&#x27;, HKDF_SIZE);
    })
    .then(function(creds) {
      return request.send(&#x27;/recoveryKey/&#x27; + recoveryKeyId, &#x27;GET&#x27;, creds);
    });
};

/**
 * Reset a user&#x27;s account using keys (kB) derived from a recovery key. This
 * process can be used to maintain the account&#x27;s original kB.
 *
 * @param accountResetToken The account reset token
 * @param email The current email of the account
 * @param newPassword The new password of the account
 * @param recoveryKeyId The recovery key id used for account recovery
 * @param keys Keys used to create the new wrapKb
 * @param {Object} [options={}] Options
 *   @param {Boolean} [options.keys]
 *   If &#x60;true&#x60;, a new &#x60;keyFetchToken&#x60; is provisioned. &#x60;options.sessionToken&#x60;
 *   is required if &#x60;options.keys&#x60; is true.
 *   @param {Boolean} [options.sessionToken]
 *   If &#x60;true&#x60;, a new &#x60;sessionToken&#x60; is provisioned.
 * @returns {Promise} A promise that will be fulfilled with updated account data
 */
FxAccountClient.prototype.resetPasswordWithRecoveryKey = function(
  accountResetToken,
  email,
  newPassword,
  recoveryKeyId,
  keys,
  options
) {
  options = options || {};
  var request = this.request;
  return Promise.resolve()
    .then(function() {
      required(email, &#x27;email&#x27;);
      required(newPassword, &#x27;new password&#x27;);
      required(keys, &#x27;keys&#x27;);
      required(keys.kB, &#x27;keys.kB&#x27;);
      required(accountResetToken, &#x27;accountResetToken&#x27;);
      required(recoveryKeyId, &#x27;recoveryKeyId&#x27;);

      var defers = [];
      defers.push(credentials.setup(email, newPassword));
      defers.push(
        hawkCredentials(accountResetToken, &#x27;accountResetToken&#x27;, HKDF_SIZE)
      );

      return Promise.all(defers);
    })
    .then(function(results) {
      var newCreds = results[0];
      var hawkCreds = results[1];
      var newWrapKb = sjcl.codec.hex.fromBits(
        credentials.xor(sjcl.codec.hex.toBits(keys.kB), newCreds.unwrapBKey)
      );

      var data = {
        wrapKb: newWrapKb,
        authPW: sjcl.codec.hex.fromBits(newCreds.authPW),
        recoveryKeyId: recoveryKeyId,
      };

      if (options.sessionToken) {
        data.sessionToken = options.sessionToken;
      }

      if (options.keys) {
        required(options.sessionToken, &#x27;sessionToken&#x27;);
      }

      var queryParams = &#x27;&#x27;;
      if (options.keys) {
        queryParams = &#x27;?keys=true&#x27;;
      }

      return request
        .send(&#x27;/account/reset&#x27; + queryParams, &#x27;POST&#x27;, hawkCreds, data)
        .then(function(accountData) {
          if (options.keys &amp;&amp; accountData.keyFetchToken) {
            accountData.unwrapBKey = sjcl.codec.hex.fromBits(
              newCreds.unwrapBKey
            );
          }
          return accountData;
        });
    });
};

/**
 * Deletes the recovery key associated with this user.
 *
 * @param sessionToken
 */
FxAccountClient.prototype.deleteRecoveryKey = function(sessionToken) {
  var request = this.request;
  return Promise.resolve()
    .then(function() {
      required(sessionToken, &#x27;sessionToken&#x27;);

      return hawkCredentials(sessionToken, &#x27;sessionToken&#x27;, HKDF_SIZE);
    })
    .then(function(creds) {
      return request.send(&#x27;/recoveryKey&#x27;, &#x27;DELETE&#x27;, creds, {});
    });
};

/**
 * This checks to see if a recovery key exists for a user. This check
 * can be performed with either a sessionToken or an email.
 *
 * Typically, sessionToken is used when checking from within the &#x60;/settings&#x60;
 * view. If it exists, we can give the user an option to revoke the key.
 *
 * Checking with an email is typically performed during the password reset
 * flow. It is used to decide whether or not we can redirect a user to
 * the &#x60;Reset password with recovery key&#x60; page or regular password reset page.
 *
 * @param sessionToken
 * @param {String} email User&#x27;s email
 * @returns {Promise} A promise that will be fulfilled with whether or not account has recovery ket
 */
FxAccountClient.prototype.recoveryKeyExists = function(sessionToken, email) {
  var request = this.request;
  return Promise.resolve().then(function() {
    if (sessionToken) {
      return hawkCredentials(sessionToken, &#x27;sessionToken&#x27;, HKDF_SIZE).then(
        function(creds) {
          return request.send(&#x27;/recoveryKey/exists&#x27;, &#x27;POST&#x27;, creds, {});
        }
      );
    }

    return request.send(&#x27;/recoveryKey/exists&#x27;, &#x27;POST&#x27;, null, {
      email: email,
    });
  });
};

/**
 * Create an OAuth code using &#x60;sessionToken&#x60;
 *
 * @param {String} sessionToken
 * @param {String} clientId
 * @param {String} state
 * @param {Object} [options={}] Options
 *   @param {String} [options.access_type=online] if &#x60;accessType=offline&#x60;, a refresh token
 *     will be issued when trading the code for an access token.
 *   @param {String} [options.acr_values] allowed ACR values
 *   @param {String} [options.keys_jwe] Keys used to encrypt
 *   @param {String} [options.redirect_uri] registered redirect URI to return to
 *   @param {String} [options.response_type=code] response type
 *   @param {String} [options.scope] requested scopes
 *   @param {String} [options.code_challenge_method] PKCE code challenge method
 *   @param {String} [options.code_challenge] PKCE code challenge
 * @returns {Promise} A promise that will be fulfilled with:
 *   - &#x60;redirect&#x60; - redirect URI
 *   - &#x60;code&#x60; - authorization code
 *   - &#x60;state&#x60; - state token
 */
FxAccountClient.prototype.createOAuthCode = function(
  sessionToken,
  clientId,
  state,
  options
) {
  options = options || {};

  var params = {
    access_type: options.access_type,
    acr_values: options.acr_values,
    client_id: clientId,
    code_challenge: options.code_challenge,
    code_challenge_method: options.code_challenge_method,
    keys_jwe: options.keys_jwe,
    redirect_uri: options.redirect_uri,
    response_type: options.response_type,
    scope: options.scope,
    state: state,
  };
  var request = this.request;

  return Promise.resolve()
    .then(function() {
      required(sessionToken, &#x27;sessionToken&#x27;);
      required(clientId, &#x27;clientId&#x27;);
      required(state, &#x27;state&#x27;);

      return hawkCredentials(sessionToken, &#x27;sessionToken&#x27;, HKDF_SIZE);
    })
    .then(function(creds) {
      return request.send(&#x27;/oauth/authorization&#x27;, &#x27;POST&#x27;, creds, params);
    });
};

/**
 * Create an OAuth token using &#x60;sessionToken&#x60;
 *
 * @param {String} sessionToken
 * @param {String} clientId
 * @param {Object} [options={}] Options
 *   @param {String} [options.access_type=online] if &#x60;accessType=offline&#x60;, a refresh token
 *     will be issued when trading the code for an access token.
 *   @param {String} [options.scope] requested scopes
 *   @param {Number} [options.ttl] time to live, in seconds
 * @returns {Promise} A promise that will be fulfilled with:
 *   - &#x60;access_token&#x60; - The access token
 *   - &#x60;refresh_token&#x60; - A refresh token, if &#x60;options.accessType=offline&#x60;
 *   - &#x60;id_token&#x60; - an OIDC ID token, returned if &#x60;scope&#x60; includes &#x60;openid&#x60;
 *   - &#x60;scope&#x60; - Requested scopes
 *   - &#x60;auth_at&#x60; - Time the user authenticated
 *   - &#x60;token_type&#x60; - The string &#x60;bearer&#x60;
 *   - &#x60;expires_in&#x60; - Time at which the token expires
 */
FxAccountClient.prototype.createOAuthToken = function(
  sessionToken,
  clientId,
  options
) {
  options = options || {};

  var params = {
    grant_type: &#x27;fxa-credentials&#x27;,
    access_type: options.access_type,
    client_id: clientId,
    scope: options.scope,
    ttl: options.ttl,
  };

  var request = this.request;
  return Promise.resolve()
    .then(function() {
      required(sessionToken, &#x27;sessionToken&#x27;);
      required(clientId, &#x27;clientId&#x27;);

      return hawkCredentials(sessionToken, &#x27;sessionToken&#x27;, HKDF_SIZE);
    })
    .then(function(creds) {
      return request.send(&#x27;/oauth/token&#x27;, &#x27;POST&#x27;, creds, params);
    });
};

/**
 * Use &#x60;sessionToken&#x60; to get scoped key data for the RP associated with &#x60;client_id&#x60;
 *
 * @param {String} sessionToken
 * @param {String} clientId
 * @param {String} scope
 * @returns {Promise} A promise that will be fulfilled with:
 *   - &#x60;identifier&#x60;
 *   - &#x60;keyRotationSecret&#x60;
 *   - &#x60;keyRotationTimestamp&#x60;
 */
FxAccountClient.prototype.getOAuthScopedKeyData = function(
  sessionToken,
  clientId,
  scope
) {
  var params = {
    client_id: clientId,
    scope: scope,
  };

  var request = this.request;
  return Promise.resolve()
    .then(function() {
      required(sessionToken, &#x27;sessionToken&#x27;);
      required(clientId, &#x27;clientId&#x27;);
      required(scope, &#x27;scope&#x27;);

      return hawkCredentials(sessionToken, &#x27;sessionToken&#x27;, HKDF_SIZE);
    })
    .then(function(creds) {
      return request.send(&#x27;/account/scoped-key-data&#x27;, &#x27;POST&#x27;, creds, params);
    });
};

/**
 * Get the list of SubHub plans from the auth server.
 *
 * @param {String} token An access token from the OAuth server.
 * @returns {Promise} A promise that will be fulfilled with a list of subscription plans from SubHub.
 */
FxAccountClient.prototype.getSubscriptionPlans = function(token) {
  var self = this;

  return Promise.resolve().then(function() {
    required(token, &#x27;token&#x27;);
    const requestOptions = {
      headers: {
        Authorization: &#x60;Bearer ${token}&#x60;,
      },
    };
    return self.request.send(
      &#x27;oauth/subscriptions/plans&#x27;,
      &#x27;GET&#x27;,
      null,
      null,
      requestOptions
    );
  });
};

/**
 * Get a user&#x27;s list of active subscriptions.
 *
 * @param {String} token A token from the OAuth server.
 * @returns {Promise} A promise that will be fulfilled with a list of active
 * subscriptions.
 */
FxAccountClient.prototype.getActiveSubscriptions = function(token) {
  var self = this;

  return Promise.resolve().then(function() {
    required(token, &#x27;token&#x27;);
    const requestOptions = {
      headers: {
        Authorization: &#x60;Bearer ${token}&#x60;,
      },
    };
    return self.request.send(
      &#x27;/oauth/subscriptions/active&#x27;,
      &#x27;GET&#x27;,
      null,
      null,
      requestOptions
    );
  });
};

/**
 * Submit a support ticket.
 *
 * @param {String} authorizationHeader A token from the OAuth server.
 * @param {Object} [supportTicket={}]
 *   @param {String} [supportTicket.topic]
 *   @param {String} [supportTicket.subject] Optional subject
 *   @param {String} [supportTicket.message]
 * @returns {Promise} A promise that will be fulfilled with:
 *   - &#x60;success&#x60;
 *   - &#x60;ticket&#x60; OR &#x60;error&#x60;
 */
FxAccountClient.prototype.createSupportTicket = function(token, supportTicket) {
  var self = this;

  return Promise.resolve().then(function() {
    required(token, &#x27;token&#x27;);
    required(supportTicket, &#x27;supportTicket&#x27;);
    const requestOptions = {
      headers: {
        Authorization: &#x60;Bearer ${token}&#x60;,
      },
    };
    return self.request.send(
      &#x27;/support/ticket&#x27;,
      &#x27;POST&#x27;,
      null,
      supportTicket,
      requestOptions
    );
  });
};

/**
 * Check for a required argument. Exposed for unit testing.
 *
 * @param {Value} val - value to check
 * @param {String} name - name of value
 * @throws {Error} if argument is falsey, or an empty object
 */
FxAccountClient.prototype._required = required;

module.exports = FxAccountClient;

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
